import { describe, it, expect, beforeEach, vi } from "vitest";
import type { TrpcContext } from "./_core/context";

// Mock database
const mockDb = {
  select: vi.fn().mockReturnThis(),
  from: vi.fn().mockReturnThis(),
  where: vi.fn().mockReturnThis(),
  limit: vi.fn().mockReturnThis(),
  insert: vi.fn().mockReturnThis(),
  values: vi.fn().mockReturnThis(),
  $returningId: vi.fn().mockReturnThis(),
};

// Mock imports
vi.mock("./db", () => ({
  getDb: vi.fn().mockResolvedValue(mockDb),
}));

describe("Telegram Duplicate Post Procedure", () => {
  let appRouter: any;
  let caller: any;
  
  const mockUser = {
    id: 1,
    openId: "test-open-id",
    name: "Test User",
    email: "test@example.com",
    role: "user" as const,
  };

  const mockContext: TrpcContext = {
    user: mockUser,
  };

  const mockPost = {
    id: 1,
    userId: 1,
    platform: "linkedin" as const,
    tone: "professional" as const,
    rawInput: "Test idea",
    generatedContent: "Test content generated by AI",
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  beforeEach(async () => {
    vi.clearAllMocks();
    // Reset mock chain
    mockDb.select.mockReturnThis();
    mockDb.from.mockReturnThis();
    mockDb.where.mockReturnThis();
    mockDb.limit.mockReturnThis();
    mockDb.insert.mockReturnThis();
    mockDb.values.mockReturnThis();
    mockDb.$returningId.mockReturnThis();
    
    const { appRouter: router } = await import("./routers");
    appRouter = router;
    caller = appRouter.createCaller(mockContext);
  });

  describe("duplicatePost", () => {
    it("should duplicate post successfully", async () => {
      // Mock finding the original post
      mockDb.limit.mockResolvedValueOnce([mockPost]);
      
      // Mock inserting the duplicate
      mockDb.$returningId.mockResolvedValueOnce([{ id: 2 }]);

      const result = await caller.telegram.duplicatePost({ postId: 1 });

      expect(result.success).toBe(true);
      expect(result.newPostId).toBe(2);
      expect(result.content).toBe("Test content generated by AI");
      expect(mockDb.select).toHaveBeenCalled();
      expect(mockDb.insert).toHaveBeenCalled();
    });

    it("should throw error if post not found", async () => {
      // Mock not finding the post
      mockDb.limit.mockResolvedValueOnce([]);

      await expect(
        caller.telegram.duplicatePost({ postId: 999 })
      ).rejects.toThrow("Post not found");
    });

    it("should create duplicate with same content but new timestamps", async () => {
      mockDb.limit.mockResolvedValueOnce([mockPost]);
      mockDb.$returningId.mockResolvedValueOnce([{ id: 3 }]);

      const result = await caller.telegram.duplicatePost({ postId: 1 });

      expect(result.success).toBe(true);
      expect(result.newPostId).toBe(3);
      // Verify insert was called with correct values
      expect(mockDb.values).toHaveBeenCalledWith(
        expect.objectContaining({
          userId: mockPost.userId,
          platform: mockPost.platform,
          tone: mockPost.tone,
          rawInput: mockPost.rawInput,
          generatedContent: mockPost.generatedContent,
        })
      );
    });

    it("should only allow user to duplicate their own posts", async () => {
      // The procedure uses ctx.user.id in the where clause
      // This test verifies the authorization check is in place
      mockDb.limit.mockResolvedValueOnce([mockPost]);
      mockDb.$returningId.mockResolvedValueOnce([{ id: 4 }]);

      await caller.telegram.duplicatePost({ postId: 1 });

      // Verify where clause includes userId check
      expect(mockDb.where).toHaveBeenCalled();
    });
  });
});
